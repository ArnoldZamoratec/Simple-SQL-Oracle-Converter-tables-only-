import re, pathlib, sys print("=== CONVERTIDOR SIMPLE A ORACLE (solo tablas) ===") # --- Utilidades de conversi√≥n --- TYPE_MAP = [ (r'\bTINYINT\b', 'NUMBER(3)'), (r'\bSMALLINT\b', 'NUMBER(5)'), (r'\bBIGINT\b', 'NUMBER(19)'), (r'\bINT\b', 'NUMBER(10)'), (r'\bINTEGER\b', 'NUMBER(10)'), (r'\bDOUBLE\s+PRECISION\b', 'BINARY_DOUBLE'), (r'\bDOUBLE\b', 'BINARY_DOUBLE'), (r'\bFLOAT\b', 'BINARY_FLOAT'), (r'\bREAL\b', 'BINARY_FLOAT'), (r'\bDECIMAL\b', 'NUMBER'), (r'\bNUMERIC\b', 'NUMBER'), (r'\bBOOLEAN\b', 'NUMBER(1)'), (r'\bTEXT\b', 'CLOB'), (r'\bVARCHAR\((\d+)\)', r'VARCHAR2(\1)'), (r'\bVARCHAR\b(?!\()', 'VARCHAR2(255)'), ] SIMPLE_REPLACEMENTS = [ (r'([^]+)', r'"\1"'), # backticks -> " " (r'\bIFNULL\s*\(', r'NVL('), (r'\bISNULL\s*\(', r'NVL('), (r'\bSUBSTRING\s*\(', r'SUBSTR('), (r'\bNOW\s*\(\s*\)', r'SYSTIMESTAMP'), (r'\bCURRENT_TIMESTAMP\s*\(\s*\)', r'SYSTIMESTAMP'), (r'\bRAND\s*\(\s*\)', r'DBMS_RANDOM.VALUE'), (r'\bTRUE\b', '1'), (r'\bFALSE\b', '0'), (r'ENGINE\s*=\s*\w+\s*', ''), (r'DEFAULT\s*CHARSET\s*=\s*\w+\s*', ''), (r'CHARSET\s*=\s*\w+\s*', ''), ] SECURITY_NOISE = [ r'(?im)^\s*GRANT\b.*?$', r'(?im)^\s*REVOKE\b.*?$', r'(?im)^\s*CREATE\s+USER\b.*?$', r'(?im)^\s*ALTER\s+USER\b.*?$', r'(?im)^\s*CREATE\s+ROLE\b.*?$', ] def convert_concat(sql:str)->str: # CONCAT(a,b,c) -> a || b || c def repl(m): inner = m.group(1) # dividir por comas sin volvernos locos (caso simple) parts = [p.strip() for p in inner.split(',')] return ' || '.join(parts) return re.sub(r'(?is)\bCONCAT\s*\((.*?)\)', repl, sql) def convert_limit_offset(sql:str)->str: # LIMIT n OFFSET m sql = re.sub(r'(?is)\s+LIMIT\s+(\d+)\s+OFFSET\s+(\d+)', r' OFFSET \2 ROWS FETCH NEXT \1 ROWS ONLY', sql) # LIMIT n sql = re.sub(r'(?is)\s+LIMIT\s+(\d+)\b', r' FETCH FIRST \1 ROWS ONLY', sql) return sql def handle_identity(sql:str)->str: # Quita AUTO_INCREMENT y convierte SERIAL sql = re.sub(r'(?i)\bAUTO_INCREMENT\b', '', sql) sql = re.sub(r'(?i)\bSERIAL\b', 'NUMBER(10) GENERATED BY DEFAULT AS IDENTITY', sql) return sql def strip_foreign_keys(sql:str)->str: # Quita l√≠neas de FOREIGN KEY y REFERENCES dentro de CREATE TABLE def clean_block(block:str)->str: # Elimina constraints de FK en el bloque block = re.sub(r'(?is),\s*CONSTRAINT\s+"?[\w$#]+"?\s+FOREIGN\s+KEY\s*\(.*?\)\s+REFERENCES\s+.*?(?=,|\))', '', block) block = re.sub(r'(?is),\s*FOREIGN\s+KEY\s*\(.*?\)\s+REFERENCES\s+.*?(?=,|\))', '', block) # Tambi√©n FK inline tipo "col INT REFERENCES otra_tabla(id)" block = re.sub(r'(?is)\s+REFERENCES\s+\S+\s*\(.*?\)', '', block) # Limpieza de comas dobles accidentales block = re.sub(r',\s*,', ',', block) block = re.sub(r'\(\s*,', '(', block) block = re.sub(r',\s*\)', ')', block) return block def repl(m): start, inner, end = m.group(1), m.group(2), m.group(3) inner_clean = clean_block(inner) return f"{start}{inner_clean}{end}" # Detecta CREATE TABLE ... ( ... ); pattern = r'(?is)\bCREATE\s+TABLE\b(.*?\()(.*?)(\)\s*;)' # 1: inicio hasta "(", 2: cuerpo, 3: cierre return re.sub(pattern, repl, sql) def only_tables(sql:str)->str: """ Deja CREATE TABLE e INSERT; elimina CREATE INDEX fuera del bloque, TRIGGER, VIEW, SEQUENCE (para mantenerlo s√∫per simple), etc. """ # Elimina triggers, views, sequences e indexes sueltos sql = re.sub(r'(?is)\bCREATE\s+TRIGGER\b.*?;', '', sql) sql = re.sub(r'(?is)\bCREATE\s+OR\s+REPLACE\s+TRIGGER\b.*?;', '', sql) sql = re.sub(r'(?is)\bCREATE\s+VIEW\b.*?;', '', sql) sql = re.sub(r'(?is)\bCREATE\s+SEQUENCE\b.*?;', '', sql) sql = re.sub(r'(?is)\bCREATE\s+INDEX\b.*?;', '', sql) # ON DUPLICATE KEY / ON CONFLICT -> comentar (fuera de alcance) sql = re.sub(r'(?is)\bON\s+DUPLICATE\s+KEY\s+UPDATE\b.*?;', r'/* TODO: Reescribir con MERGE */', sql) sql = re.sub(r'(?is)\bON\s+CONFLICT\b.*?;', r'/* TODO: Reescribir con MERGE */', sql) return sql def main(): # --- 1) Pide el archivo de entrada --- in_path = input('üìÑ Ingresa el nombre del archivo .sql de origen (ej: users_icpna.sql): ').strip().strip('"') if not in_path: print("‚ö†Ô∏è No ingresaste archivo. Saliendo.") sys.exit(1) p = pathlib.Path(in_path) if not p.exists(): print(f"‚ö†Ô∏è No se encontr√≥: {p.resolve()}") sys.exit(1) # --- 2) Define salida --- out_path = p.with_name(p.stem + "_oracle.sql") text = p.read_text(encoding="utf-8", errors="ignore") # --- 3) Limpieza de seguridad/ruido --- for pat in SECURITY_NOISE: text = re.sub(pat, '', text) # --- 4) Reemplazos simples --- for pat, rep in SIMPLE_REPLACEMENTS: text = re.sub(pat, rep, text, flags=re.IGNORECASE) # --- 5) Tipos de datos --- for pat, rep in TYPE_MAP: text = re.sub(pat, rep, text, flags=re.IGNORECASE) # --- 6) IDENTIDAD y LIMIT/OFFSET / CONCAT --- text = handle_identity(text) text = convert_concat(text) text = convert_limit_offset(text) # --- 7) Mantener solo tablas e inserts; quitar FKs --- text = only_tables(text) text = strip_foreign_keys(text) # --- 8) Espacios bonitos --- text = re.sub(r'\n{3,}', '\n\n', text).strip() + '\n' out_path.write_text(text, encoding="utf-8") print(f"‚úÖ Listo. Archivo generado: {out_path.name}") print(" (Col√≥calo en Oracle SQL Developer y ejec√∫talo).") if __name__ == "__main__": main()
